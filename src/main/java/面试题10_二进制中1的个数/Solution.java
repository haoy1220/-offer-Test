package 面试题10_二进制中1的个数;

/**
 * @author Hao
 * @date 2019/11/15 16:48
 */

/*
 * 题目描述
 * 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
 * [+1] = [00000001]原 = [00000001]反 = [00000001]补
 * [-1] = [10000001]原 = [11111110]反 = [11111111]补
 */

/*
 * 思路
 * 1.首先可以想到的是可以通过与1判断最低位是不是1，之后整数一直右移就好了，但是题目可能会有负数，右移会用1补全，会无限循环，所以该方案不行；
 * 2.原整数行不通可以从判断数入手，将原值为1的判断数每次判断完左移一位，只要每次想与结果与判断数相等，说明那一位是1，直到判断数为0；
 * 1010 1010；1010 1010；1010 1010；1010 1010；1010 1010；1010 1010；1010 1010；1010 1010；
 * 0000 0001；0000 0010；0000 0100；0000 1000；0001 0010；0010 0000；0100 0000；1000 0000；
 * 0000 0000；0000 0010；0000 0000；0000 1000；0000 0000；0010 0000；0000 0000；1000 0000；结果为4
 */
public class Solution {
    public int NumberOf1(int n) {
        int counter = 0;
        int flag = 1;

        while (flag != 0) {
            if ((n & flag) == flag) {
                counter++;
            }
            flag = flag << 1;
        }
        return counter;
    }
}

/*
 * 思路
 * 原：   1100
 * 减1后：1011
 * 与后： 1000 消去了最右边的1，直到0结束
 */
class Solution2 {
    public int NumberOf1(int n) {
        int counter = 0;
        while (n != 0) {
            n = n & (n - 1);
            counter++;
        }
        return counter;
    }
}

/*
 * 总结
 * 1.<<左移，右边用0补充；>>右移，正数左边用0补充，负数左边用1补充；
 * 2.可以从不同的对象切入对象，比如原整数角度、判断数角度；
 * 3.把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数二进制表示中的最右边一个1变成0.很多二进制的问题都可以用这个思路解决。
 */
